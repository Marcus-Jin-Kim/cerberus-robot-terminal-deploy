# cb ai turret udp + flask mjpeg server
import os, sys, signal, atexit
import yaml
# from cb_low_level_control import CBLowLevelControl
from cb_robot_control import CBRobotControl
import socket, time, json, threading
from typing import Optional
from urllib.parse import parse_qs

# Flask for MJPEG stream
from flask import Flask, Response, jsonify

import traceback


class CerberusRobotTerminalServer:

    def __init__(self, config_file="../cb_config.yaml",                 
        # , host='0.0.0.0', udp_port=5001, http_port=5100,
        #    return_image_override=None, control_turret_override=None, auto_aim_override=None
         ):

        self.config = self._load_config(config_file)
        self.host = self.config.get("ROBOT_TERMINAL_SERVER_HOST")
        self.udp_port = self.config.get("ROBOT_TERMINAL_SERVER_UDP_PORT")
        self.http_port = self.config.get("ROBOT_TERMINAL_SERVER_HTTP_PORT")
        self.control_hz = self.config.get("ROBOT_TERMINAL_SERVER_ROBOT_CONTROL_HZ")
        self.stream_fps = self.config.get("ROBOT_TERMINAL_SERVER_STREAM_FPS")

        print(f"[SERV] Robot control HZ = {self.control_hz}")

        self.udp_server = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        self.udp_server.bind((self.host, self.udp_port))

        self.robot_control = CBRobotControl(config=self.config)

        self._lock = threading.Lock()
        self.last_json: Optional[dict] = None
        self.last_jpeg: Optional[bytes] = None
        self.last_ts: float = 0.0

        from cb_cmd_routes import create_routes_blueprint
        self.app = Flask(__name__)
        self.app.register_blueprint(create_routes_blueprint(self))

        print(f"[SERV] UDP on {self.host}:{self.udp_port}, HTTP on {self.host}:{self.http_port}")

        # Start background threads immediately on instantiation
        print("[SERV] Starting background threads...")
        threading.Thread(target=self._robot_control_loop, daemon=True).start()
        threading.Thread(target=self._udp_loop, daemon=True).start()
        print("[SERV] Background threads started.")


    def mjpeg_gen(self):
        period = 1.0 / max(1, self.stream_fps)
        while True:
            t0 = time.time()
            with self._lock:
                jpg = self.last_jpeg
            if jpg:
                yield (b"--frame\r\nContent-Type: image/jpeg\r\n\r\n" + jpg + b"\r\n")
            dt = time.time() - t0
            if dt < period:
                time.sleep(period - dt)

    def _robot_control_loop(self):
        # Capture/process loop: updates shared JSON and JPEG once per cycle
        while True:
            t0 = time.time()
            wait_for_second = 1.0 / max(1, self.control_hz)
            try:
                res = self.robot_control.scan_enemy()
            except Exception as e:
                tb = traceback.extract_tb(e.__traceback__)[-1]
                print(f"[AI ] detect_pose error at {tb.filename}:{tb.lineno} in {tb.name}: {e}")
                time.sleep(0.05)
                continue

           # Build outputs OUTSIDE the lock
            jpeg: bytes = None
            if isinstance(res, dict) and res.get("return_image", False):
                v = (res.get("data") or {}).get("jpg_image_bytes")
                jpeg = v
                # if isinstance(v, bytes):
                #     jpeg = v                    # zero-copy
                # elif isinstance(v, (bytearray, memoryview)):
                #     jpeg = bytes(v)             # one copy to immutable

            # copy res to self.last_json except ["data"]["jpg_image_bytes"]
            clean = {"OK": False, "error": "bad_result"}
            if isinstance(res, dict):
                clean = res.copy()              # shallow copy
                d = clean.get("data")
                if isinstance(d, dict):
                    d = d.copy()
                    d.pop("jpg_image_bytes", None)
                    clean["data"] = d

            # Minimal critical section
            with self._lock:
                self.last_jpeg = jpeg           # may be None if not returning image
                self.last_json = clean
                self.last_ts = time.time()


            dt = time.time() - t0
            if dt < wait_for_second:
                time.sleep(wait_for_second - dt)

    def _udp_loop(self):
        # Serve small JSON (no images) over UDP
        self.udp_server.settimeout(0.5)  # set once
        while True:
            try:
                data, addr = self.udp_server.recvfrom(2048)
            except socket.timeout:
                continue
            except Exception as e:
                print(f"[UDP] recv error: {e}")
                continue

            # Expect URL-encoded query, e.g., b"req=mp-pose"
            try:
                text = data.decode("utf-8", errors="ignore").strip()
                if not text:
                    continue
                qs = parse_qs(text, keep_blank_values=True)
                req = (qs.get("req") or [""])[0]
            except Exception:
                continue

            if req == "mp-pose":
                with self._lock:
                    reply = self.last_json if self.last_json is not None else {"OK": False, "error": "no_data"}
                try:
                    # just drop jpeg_image_bytes in data since udp sever doesnt serve it
                    if "data" in reply and isinstance(reply["data"], dict):
                        reply["data"].pop("jpeg_image_bytes", None)

                    payload = json.dumps(reply).encode("utf-8")                    
                    self.udp_server.sendto(payload, addr)

                except Exception as e:
                    print(f"[UDP] send error: {e}")

    def start_dev_server(self):
        # This method is now only for direct development runs, NOT for Gunicorn
        print("[SERV] Starting Flask development server...")
        self.app.run(host=self.host, port=self.http_port, threaded=True, use_reloader=False, debug=False)

        
    def _load_config(self, config_file):
        try:
            with open(config_file, 'r') as f:
                config = yaml.safe_load(f)
                print(f"[SERV] Loaded config: {config}")
                return config
        except Exception as e:
            print(f"[SERV] Error loading config: {e}")
            return {}
        pass

# --- This part is now at the module level ---
# Gunicorn will find these objects when it imports the file.
server = CerberusRobotTerminalServer()
app = server.app # Expose the app object for Gunicorn


if __name__ == "__main__":
    # This block is now only for running the script directly for development/debugging.
    # Gunicorn will NOT run this.
    
    # write down pid
    pid_file_path = "../cb_pid_terminal.txt"
    with open(pid_file_path, "w") as f:
        f.write(str(os.getpid()) + "\n")

    def _cleanup_pidfile():
        if os.path.exists(pid_file_path):
            os.remove(pid_file_path)
            print("[SERV] PID file removed.")

    def _on_signal(signum, frame):
        print(f"[SERV] signal {signum} received; exiting")
        _cleanup_pidfile()
        sys.exit(0)

    atexit.register(_cleanup_pidfile)
    signal.signal(signal.SIGTERM, _on_signal)
    signal.signal(signal.SIGINT, _on_signal)

    try:
        # Call the development server method
        server.start_dev_server()
    finally:
        _cleanup_pidfile()
        print("[SERV] Server stopped.")
